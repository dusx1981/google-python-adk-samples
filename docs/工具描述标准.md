## 🌐 OpenAPI 规范 v3.0.3 中文翻译与详细解析

OpenAPI 规范 (OAS) v3.0.3 是一个定义了 RESTful API 标准化、**与编程语言无关的接口描述**的技术标准。它使得人和计算机无需访问源代码、额外文档或检查网络流量，就能发现并理解服务的功能。

下面是该规范核心内容的详细翻译与解释。

### 📜 1. 规范摘要与状态
- **版本**：3.0.3 (发布于 2020年2月20日)
- **最新版本**：建议关注官方发布的最新版（当前链接中列出了 v3.2.0 等更高版本）。
- **文档状态**：此 HTML 文件是此规范的**权威来源**。
- **许可证**：Apache License, Version 2.0。

### 🎯 2. 核心目标
OpenAPI 规范旨在为 HTTP API 提供一个标准化的描述方式。当一个 API 被正确描述后：
- **消费者**可以用最少的实现逻辑来理解和远程服务交互。
- **工具**可以基于此定义生成文档、客户端/服务器端代码、进行测试等。

它类似于低级编程中的接口描述，**消除了调用服务时的猜测工作**。

### 📖 3. 关键术语解释
| 术语 | 中文解释 | 关键点说明 |
| :--- | :--- | :--- |
| **OpenAPI Document** | OpenAPI 文档 | 定义或描述 API 的一个或多个文件，需符合 OAS 格式。 |
| **Path Templating** | 路径模板化 | 使用花括号 `{}` 包围的模板表达式来表示 URL 路径中的可变部分（路径参数）。 |
| **Media Types** | 媒体类型 | API 请求和响应内容的格式，如 `application/json`。应符合 RFC6838。 |
| **HTTP Status Codes** | HTTP 状态码 | 用于指示操作执行的状态，遵循 RFC7231 和 IANA 状态码注册表。 |

### ⚙️ 4. 规范技术细节详解

#### 4.1 版本管理
- **遵循规则**：采用**语义化版本 2.0.0**。
- **主版本.次版本** (如 `3.0`)：代表 OAS 的功能集。补丁版本 (如 `.3`) 通常仅修正文档错误，**不新增功能**。
- **兼容性**：支持 OAS 3.0 的工具应兼容所有 `3.0.*` 版本。在同一主版本内，新次版本须保持向后兼容（通常只需更新 `openapi` 属性值即可迁移）。
- **版本标识**：OAS 3.x 文档必须包含一个标识其所用 OAS 版本的 `openapi` 字段 (OAS 2.0 文档则使用 `swagger: “2.0”`)。

#### 4.2 文档格式
- **格式**：OpenAPI 文档本身是一个 **JSON 对象**，可以用 **JSON 或 YAML** 格式表示。
- **大小写敏感**：规范中的所有字段名**均区分大小写**。
- **字段类型**：
    - **固定字段**：有预先声明的名称。
    - **模式字段**：字段名需匹配某个正则表达式模式，且在同一对象内必须唯一。
- **YAML 约束**：为保持与 JSON 的双向转换能力，建议使用 YAML 1.2，并遵守 JSON Schema 规则集。

#### 4.3 文档结构
- 文档可以是一个**单一文件**，也可以被拆分为**多个通过引用连接的部分**。
- 引用时**必须使用 `$ref` 字段**。
- 根文档推荐命名为 **`openapi.json`** 或 **`openapi.yaml`**。

#### 4.4 数据类型
- **基础类型**：基于 JSON Schema，支持 `integer`, `number`, `string`, `boolean` 等。**不支持 `null` 类型**（可用 `nullable` 属性替代）。
- **格式修饰**：基础类型有一个可选的 `format` 属性，用于更精细地定义数据类型（如 `string` 的 `date`, `password`；`integer` 的 `int32`）。`format` 是开放式属性，即使规范未明确定义（如 `”email”`, `”uuid”`）也可使用。

#### 4.5 富文本格式
- **描述字段**：规范中的 `description` 字段支持使用 **[CommonMark](https://commonmark.org/)** 标记语法进行富文本格式化。

#### 4.6 相对 URL 引用
- 除非另有规定，所有 URL 属性**都可以是相对引用**。
- 相对引用使用 **Server Object 中定义的 URL 作为基础 URI** 进行解析。
- `$ref` 中的相对引用则按 JSON Reference 规则，**以当前文档的 URL 为基址**进行解析。

### 🏗️ 5. 核心对象模型详解

#### 5.1 OpenAPI 对象 (根对象)
这是整个 OpenAPI 文档的根对象，结构如下：

| 字段名 | 类型 | 是否必需 | 描述 |
| :--- | :--- | :--- | :--- |
| **`openapi`** | `string` | **必需** | 指明文档所使用的 OAS 语义版本号（如 `”3.0.3”`）。 |
| **`info`** | `Info Object` | **必需** | 提供关于 API 的元数据。 |
| **`paths`** | `Paths Object` | **必需** | API 的可用路径和操作，是核心定义部分。 |
| `servers` | `[Server Object]` | 可选 | 服务器连接信息数组。未提供时默认值为 `[{“url”: “/”}]`。 |
| `components` | `Components Object` | 可选 | 用于存放可重用的模式、参数、响应等组件。 |
| `security` | `[Security Requirement Object]` | 可选 | 声明可在整个 API 使用的安全机制。 |
| `tags` | `[Tag Object]` | 可选 | 用于为操作分组的标签列表，含元数据。 |
| `externalDocs` | `External Documentation Object` | 可选 | 附加的外部文档链接。 |

*此对象可通过“规范扩展”进行扩展。*

#### 5.2 Info 对象
提供 API 的元数据。

| 字段名 | 类型 | 是否必需 | 描述 |
| :--- | :--- | :--- | :--- |
| **`title`** | `string` | **必需** | API 的标题。 |
| **`version`** | `string` | **必需** | **OpenAPI 文档的版本**（区别于 OAS 版本或 API 实现版本）。 |
| `description` | `string` | 可选 | API 的简短描述，支持 CommonMark。 |
| `termsOfService` | `string` | 可选 | API 服务条款的 URL。 |
| `contact` | `Contact Object` | 可选 | 公开 API 的联系信息。 |
| `license` | `License Object` | 可选 | 公开 API 的许可证信息。 |

**示例**：
```json
{
  “title”: “示例宠物商店应用”,
  “description”: “这是一个宠物商店的示例服务器。”,
  “version”: “1.0.1”,
  “contact”: {
    “name”: “API 支持”,
    “url”: “http://www.example.com/support”,
    “email”: “support@example.com”
  },
  “license”: {
    “name”: “Apache 2.0”,
    “url”: “https://www.apache.org/licenses/LICENSE-2.0.html”
  }
}
```

#### 5.3 Contact 对象 与 License 对象
- **Contact 对象**：包含 `name`、`url`、`email` 字段，均需符合相应格式。
- **License 对象**：**必须**包含 `name` 字段，可选 `url` 字段。

### 💡 6. 重要提示与实践建议
1.  **向前看**：v3.0.3 是一个稳定版本，但建议开始了解 **v3.1.x** 等更新版本，它们引入了如 `webhooks` 等重要新特性。
2.  **工具生态**：利用成熟的 OpenAPI 工具链（如 Swagger UI 生成文档、OpenAPI Generator 生成代码）来提升开发效率。
3.  **设计优先**：采用“设计优先”的 API 开发策略，先编写 OpenAPI 文档作为唯一事实来源，再据此开发和测试。
4.  **充分利用组件**：使用 `components` 对象集中定义可重用的数据结构、参数和响应，**保持文档的整洁和一致性**。
5.  **安全性声明**：在根节点的 `security` 字段声明全局安全方案（如 API Key, OAuth2），并可在具体操作中覆盖。

如果你想深入了解某个特定部分（如 `Paths` 对象如何定义具体操作，或 `Components` 的详细用法），我可以继续为你详细展开解释。